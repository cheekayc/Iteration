---
title: "Writing Functions"
author: "Lectured by Jeff Goldsmith"
date: "2022-10-27"
output: github_document
---

```{r setup, message = FALSE}
library(tidyverse)
library(rvest)

set.seed(1) 
```

# Write Functions

If we use the same code more than twice, write a function.

### Let's get some Z-scores!

We know that Z-score = (x - mean)/sd. 
```{r create a variable x_vec}
# First create a variable that contains a list of numeric values.
x_vec = rnorm(25, mean = 7, sd = 4)

# Then we compute the Z-scores of this set of numbers.
(x_vec - mean(x_vec)) / sd(x_vec)
```

Suppose we want to do this often. I.e. what if we want to calculate the Z-scores for different set of variables? We would have to copy & paste the code so many times! So we should write a function. 
```{r set function for z_scores}
# z_scores = function(ARGUMENTS) {
  
#  BODY OF FUNCTION

#  }

z_scores = function(x) {       # z_scores is a function of (x) that do the following:
  z = (x - mean(x)) / sd(x)    # calculate z by the equation stated.
  z                            # show the output of z. If we don't do this, the output will not be shown.
}
```

Now let's check if the function works.
```{r check function, eval = FALSE}
z_scores(x = x_vec)  

z_scores(x = 1:10)

z_scores(x = rbinom(1000, 1, 0.6))

z_scores(x = 3) # Returned "NA". Can't do this because if x is only one number, R can't compute the sd of just one number.

z_scores(x = "My name is Jeff") # Can't do this because R cannot do mathematical computations with non-numeric variable.
```

When the variable "x" only contain one number, or the variable "x" is a character vector, R will give us an error warning. So how do we fix this?
```{r fixing by specifying}
z_scores = function(x) {
  if (!is.numeric(x)) {   # meaning if R encounter something that is NOT numeric, stop the function and tell me...
    stop("Argument x should be numeric")}
  else if (length(x) == 1) {  # if the number of values in "x" is less than 2, stop the function and tell me...
    stop("Z scores cannot be computed for length 1 vectors")}
  
  z = mean(x) / sd(x)
  
  z
}
```

Now try...
```{r try again, eval = FALSE}
z_scores(x = 3)

z_scores(x = "My name is Jeff")
```


## Let's have multiple outputs

Say, instead of just showing the output of Z-scores, I want an output that gives me the mean, standard deviation and Z-scores.
```{r three things at once}
mean_sd_z = function(x) {
  # make sure we define specific conditions before we define the function.
  if (!is.numeric(x)) {   
    stop("Argument x should be numeric")}
  else if (length(x) == 1) { 
    stop("Z scores cannot be computed for length 1 vectors")}
  mean_x = mean(x)
  sd_x = sd(x)
  z_scores = (16 - mean(x)) / sd(x)  # here I just simply assign a fix number "16" for no reason.
  
#How do I return all of them at once? Create a tibble!
  tibble(
    mean = mean(x),
    sd = sd_x,
    z_score = z_scores)
}

mean_sd_z(x = x_vec)
mean_sd_z(x = 1:10)
mean_sd_z(x = rbinom(50, 1, 0.5))
```


## *Simulations*

What if I want to repeat the function I just created so many times for different samples or even different sample sizes?
```{r}
# I am going to create a set of values for x:
x_vec = rnorm(n = 25, mean = 7, sd = 4)

# Then, I'll create a dataframe that gives me the mean and sd of the vectors I just created.
tibble(
  mean = mean(x_vec),
  sd = sd(x_vec))

# If we run this code chunk many times, we will get different values every time.
```

**Simulation** can help us run the function so many times with different mean, sd, and sample sizes.
```{r}
# I should create a function first.
# In this function, I am setting the default value for true mean and true_sd. 
sim_mean_sd = function(n_obs, true_mean = 7, true_sd = 4) {
  # I am creating a x-variable inside this function and use it inside this function.
  x = rnorm(n = n_obs, mean = true_mean, sd = true_sd)
  # If I specify the n = 1000, it will only run 1000 observations. But if I don't specify the n, it will run whatever the sample size is.
  tibble(
    mean = mean(x),
    sd = sd(x))
}
```

Now check if the function works.
```{r}
# If I don't specify the true_mean & true_sd, it will just assume the default true_mean & true_sd (recall when we create the function, we set a default values for true_mean & true_sd)
sim_mean_sd(n_obs = 30)

# Now that I specified the true_mean & true_sd it will not use the default values but will use the one I specified here.
sim_mean_sd(n_obs = 25, true_mean = 10, true_sd = 5)

# We can also not name out the argument, just put the numbers in. R will assume the first value is n_obs, the second is true_mean, and the third is true_sd.
sim_mean_sd(2500, 10, 7)

# I can also name out the argument and don't put it in order. It will still work because I named out the arguments.
sim_mean_sd(true_sd = 2, n_obs = 3000, true_mean = 165)
```


## Fixing bad stuff

In the previous lecture, we selected reviews of *Napoleon Dynamite* from only one page. If we want all the reviews from tens or hundreds of
page, we would have to copy and paste the same function hundreds of time, and each time we would have to change the page number...That's a
lot of work...

We can do the following instead! Save our lives!

First, write a function to get reviews.
```{r}
# I am going to name my function "read_reviews". The only argument I need in this function is the url because it will read the pages from the url I specified.
read_reviews = function(url) {
  # I need to create a variable to read the url.
  napoleon_html = read_html(url)
  # Then I create different variables to do different things so that I can create a tibble later.
  review_titles = 
    napoleon_html %>%
    html_nodes(".a-text-bold span") %>%
    html_text()

  review_stars = 
    napoleon_html %>%
    html_nodes("#cm_cr-review_list .review-rating") %>%
    html_text() %>%
    str_extract("^\\d") %>%
    as.numeric()

  review_text = 
    napoleon_html %>%
    html_nodes(".review-text-content span") %>%
    html_text() %>% 
    str_replace_all("\n", "") %>% 
    str_trim()

  reviews = tibble(
    title = review_titles,
    stars = review_stars,
    text = review_text)
}
```

Now let's see if this function works:
```{r}
base_url = "https://www.amazon.com/product-reviews/B00005JNBQ/ref=cm_cr_arp_d_viewopt_rvwer?ie=UTF8&reviewerType=avp_only_reviews&sortBy=recent&pageNumber="
# Remember to remove the page number.

# I'm creating a variable 
vec_urls = str_c(base_url, c(1:5))

dynamite_reviews = 
  bind_rows(
    read_reviews(vec_url[1]),
    read_reviews(vec_urls[2]),
    read_reviews(vec_urls[3]),
    read_reviews(vec_urls[4]),
    read_reviews(vec_urls[5])
  )

dynamite_reviews

# Page 3 doesn't work with this code because there is a picture in one of the comment.
```

```{r}
fellowship_ring = readxl::read_excel("./data/LotR_Words.xlsx", range = "B3:D6") %>%
  mutate(movie = "fellowship_ring")

two_towers = readxl::read_excel("./data/LotR_Words.xlsx", range = "F3:H6") %>%
  mutate(movie = "two_towers")

return_king = readxl::read_excel("./data/LotR_Words.xlsx", range = "J3:L6") %>%
  mutate(movie = "return_king")

lotr_tidy = bind_rows(fellowship_ring, two_towers, return_king) %>%
  janitor::clean_names() %>%
  gather(key = sex, value = words, female:male) %>%
  mutate(race = str_to_lower(race)) %>% 
  select(movie, everything()) 
```

```{r}
lotr_load_and_tidy = function(path, range, movie_name) {
  
  df = readxl::read_excel(path, range = range) %>%
    janitor::clean_names() %>%
    gather(key = sex, value = words, female:male) %>%
    mutate(race = str_to_lower(race),
           movie = movie_name)
  
  df
  
}

lotr_tidy = 
  bind_rows(
    lotr_load_and_tidy("./data/LotR_Words.xlsx", "B3:D6", "fellowship_ring"),
    lotr_load_and_tidy("./data/LotR_Words.xlsx", "F3:H6", "two_towers"),
    lotr_load_and_tidy("./data/LotR_Words.xlsx", "J3:L6", "return_king")) %>%
  select(movie, everything()) 
```


## Variables Scoping and Names

Variables that we created inside a function stay inside the function. If we try to search for the variables outside the function, they don't exist. 

But we also don't want to create a variable outside a function and use that variable inside a function because then R will step out of the function to look for that variable. This can potentially cause us problem.

